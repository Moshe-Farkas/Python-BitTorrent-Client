
Torrent is a data structure that hold decoded / parsed data read from the .torrent file.



after Torrent object is created peers should be handshaked.


peers:
    ip
    port
    state


when a client downloads a block from a peer it should yield control to the writing to disk coroutine
which yields back control when it finishes. the event loop should be filled with these downloading from peers
coroutines


step 1:
    send and receive handshake


piece.blocks should be an iterator generator. block_to_download = next(piece.blocks)


TorrentSession:
    - main should build the Torrent info object and give it to the session constructor
    - ability to start up session as a retry. needs the folder of already downloaded pieces.
    - ability to re-request peers from tracker based on the tracker interval
    - stats on num of pieces downloaded
    - needs a work queue of uncompleted and un-in-progress pieces
    - start_session will be called only once. it will use private methods to get response from tracker and will
      re-request after interval time. when getting a response back it needs to pick up peers that aren't currently being
      downloaded from.

    - needs to generate piece empty piece blueprints
    - needs to compare hashes of completed hashes
    - needs to run file_saver start coro
    - needs build and send handshake to each Peer it creates


    interface:
        download_finished()
        get_piece_from_work_queue()
        put_piece_back_to_work_queue()



retry ability:
    torrent session needs to check if temp-torrent-parts dir exists.
    if yes:
        serialize it into the dict of unfinished pieces.
    else:
        mkdir
        and init all pieces



multi-file mode:
    torrent-session should look at downloading the torrent as a single file with a single list of pieces.
    the file_saver needs to figure out how to assemble it to disk in order.
    a single piece can span multiple files.
    file saver should create if not exists a dir called torrent-parts and store all pieces in there until
    it's time to assemble the final file(s).
    file-saver:
        all it needs is file information (dict of name and length)


tracker generator:



